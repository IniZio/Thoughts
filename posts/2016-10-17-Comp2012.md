---
title: Comp2012
category: Study
tags: [ comp2012 ]
date: 2016-10-17
filename: 2016-10-17-Comp2012
---

## L2

- can define function in struct in C++, but not in C
- in C it is hard to maintain relatinships between structure data members
- OOP properties:
  - class
  - objects
  - inheritence
  - polymophism
  - dynamic binding
- Supports in OOP:
  - Data abstraction (abstract data type)
  - Data enscuplation (information hiding)

## L3 (skipped)

## L4

> 星期三, 14. 九月 2016 05:17下午

- inline functions are suitiable for short/simple statements, less readable
- if not put inline keyword, compilor will decide whether to make it inline
- if add inline to function, then it will become inline no matter what
- variable chooses the nearest declaration/initialiation value

## L6

- with g++ command, link other libraries using '-l' option
- a c++ library is of extension '.a', and has a prefix 'lib'
  e.g. `g++ -o myprog myprog.o -l ABC` finds a library called 'libABC.a'

### Static linking vs dynamic linking

- Static:
  - run faster
  - larger file size
- Dynamic:
  - run slower
  - less portable as the machine may not have the library
  - smaller file size

### #include `<>` vs #include ""

- \#: preprossor directive
- `<>`: standard header files
- "": user-defined header files searched in current directory. Can be changed with '-I' option

### 3 lines of codes in header file

```cpp
#IFNDEF HAHA_H
#DEFINE HAHA_H

#ENDIF
```

## L5

#### Passing objects

- Should nearly always pass objects as reference. If for getters then add 'const' in function parameter

#### Differences between Reference and Pointer

- Pointer can be pointed at nothing(NULL), reference cant
- Pointer can point to different objects at different times, reference cant. Instead assignments to it is applied to the value of its referenced object
- Nme of pointer refers to pointer object, so uses `*` and `->`. Name of reference always refers to the object

## Usage of const

- ojects not intend to change
- funcstion arguments not intend to change
- member functions that do not change data members (e.g. getters)

## ALERT! never assign values to data members in initialization

```cpp
clas abc {
	private:
	int good;
	// int bad = 1; // cuz it errors in old compiler
}
```

### If there is char string in parameter of constructor, then it won't call default constructor even if the object declaration does not have any parameters (four/constrctor.cpp)

`int a(10)` works and is same as `int a = 10`

## L6

```cpp
class Word{
public:
	explicit Word()
}
```

- 'explicit' is like preventDefault in js

### Copy constructor

```cpp
class A {
public:
	A(const A& a) {
		x = a.x;
		y = a.y;
	}
	A reflect() { return *this } // this also calls a copy constructor
}
```

#### When a copy constructor is triggered

- When u pass a object as parameter (normal copy)
- When u return an object by value in the function

#### Why use copy constructor

- Control level of copy/ what to copy

#### There is a default copy constructor too, which copies all data members one by one

##### Problem with default copy constructor

- Pointers copy the address so is kind of same, instead of copied to become independent(a.k.a shallow copying)

```cpp
class A {
private:
	int* arr; // Notice this pointr of array
public:
	A() { arr = new int[10];}
};

int main() {
	A obj1;
	A obj2(obj1);
}
```

#### Correct way to make pointer deep copied as well

```cpp
class A {
private:
	int* arr; // Notice this pointr of array
public:
	A() { arr = new int[10];}
	A(const A& a) {
		arr = new int[10];
		for (int i = 0; i < 10; i++) {
			arr[i] = a.arr[i];
		}
	};
};
```

```cpp
Word hkust = "hkust" // implicit conversion constructor
```

## L7

#### Member initialization list

```cpp
class A {
private:
	int a, b, c;
	const int d;
	// member initialization list
	A(): a(1), b(2), c(3), d(4){ // this way directly assigns and initializes the values at the same time
	}
	// is the same as:
	A() {
		a = 1; b=2;c=3; // this way will initialize the members before assigning the values
		d = 4 // illegal
	}
}
```

## L8

#### when copy a char string to another char string, the length in new must be +1-ed:

```cpp
void receive_string(const char* s = "abc") {
  char* str = new char[strlen(s)+1]; strcpy(str, s);
}
```

##### When an object is already constructed, assigning another object to it does not trigger constructor

##### A object is killed before its data members. Reason: C++ stores the programs and variables as stack, and data members are constructed first i.e. FILO

#### If in constructor we assigned a data member a object:

```cpp
tree A;
World() {
  A = tree(1);
}
```

it gives two destructor. one for the data member itself, one for the tree(1), which is another unnamed but created object



## L9

### Generic programming

```cpp
template <typename T>
  T my_max(const T& a, const T& b) {
    return (a>b)?a:b;
  }
int main() { int c = my_max(10, 11); }
```

- ==*== If you pass parameters with different types at once though it will give error e.g. `double c = my_max(4,5.5)`

  - solution: (use a new typename for each parameter possibly with different type )

    ```cpp
    template <typename T1, typename T2>
      T my_max(const T1& a, const T2& b) {
        return (a>b)?a:b;
      }
    int main() { int c = my_max(10, 11); }
    ```

- Cannot set `typename` for return type

- It is useful for container classes e.g.

  ```cpp
  template <typename T>
    class A {
      private:
      T* arr;
      public:
      A () {arr = new T[100];}
    }
  int main() {
    A <int> something;
  }
  ```

### Operator overloading

- What you see: `c =a+b`
  Whtat c++ does: `int c = operator+(a,b)`,  or `int c = a.operator+(b)`
- handilling `<<` or `>>`: `ostream & operator<<(ostream& os, const A& x) {...} `, ` istream & operator<<(istream& os, const A& x) {...} `

## L10

##### Unlike normal functions, templates i.e. `template <typename T>`cannot be separated to header and cpp files.

## L11

#### Operator overloading

- Usually return by value unless you are returning a existing object or the operator changes the existing object

######the const of `int X::abc() const {}` means it cannot modify class members

### Stupid type checking in operator overloading scenerio

- Works :thumbsup:: `cout << b + 4.2 << endl;` given b is a custom class and have made the operator+ to handle
- Fails ​:thumbsdown:​: `cout << 8.9 + a << endl;` gives error no matter what you do...

##### Add `const` to return type in operator overloading if we do not want cascading assignments e.g. `a=b=c=d`, otherwise omit that.

## L12

#### Preventing left to right assignment in cascading assignment(six/)

```cpp
class A
{
public:
	const A& operator=(const A& a) {
		return *this;
	}
};

int main(int argc, char const *argv[])
{
	A x,y,z;
	x=y=z;
	// (x=y)=z; // errors as const in return type prevents that
	return 0;
}
```

#### Using 2 methods for same operator overloading (seven/)

```cpp
int operator[](int w) const{...} // read-only (required for const object)
int& operator[](int w) {...} // read-write
```

##### Post and Pre operators

```cpp
A& operator++(){}; //++a // cannot return new object
A operator++(int){}; //a++ //must have 'int' in parameter, can return new object
```

```cpp
int a = 5;
++a = 6; //Legit
//a++ = 6; //Illegal
```

#### Call another class/function a friend

```cpp
class A {
  private:
  	friend class B;
  	friend void x();
}
```

###### friend function is class is not a member function

- ### Generic Programming

  - Definition: programming with types as parameters

  - Careful with comparison operators for custom objects if only compare member data, since defaults compare and return the object itself

  - #### STL

    - Provides Containers to hold elements e.g. Linked List, stack, queue, tree.

      Provides Iterators(like pointers).

      Provides Algorithm e.g. sorting

    - Linked List

      - Array vs  linked list
        - LL is easier to merge and split 
        - LL is dynamic
        - LL' s access speed is low

    - ###### Containers

      - are class templates

      - 3 concepts of container

        1. kind of containeer (e.g. list-based, array-based)
        2. kind of objects (data type)
        3. kind of operations on the elements in container (mutations)

      - ###### Includes

        1. Sequence containers: linear structure, start from 0 like array
        2. Associative containers: non-sequential, key/value pairs
        3. Container adapters: uses other containers as storage, and provide different set of  member functions. E.g. Stack since it can be stored using vectors, linked lists
           - priority queue (i.e. heap)
        4. Near-containers: string, valarray

      - Deque (double ended queue):  dynamically expand/contract the storage without copying elements.

      - Containers in same category share same/similar public member functions

      - possible to remove/reduce reliance between the 3 concepts using generic programming

      - Container classes

        - holds collection of homogeneous objects
        - does not need to know the object type when designed

      - Sequence Containers: other operation

        - insert(p,x) , erase(p): p is iterator, x is the element
        - clear()
        - size(), empty(), resize(int new_size)
        - operators ==, !=, <

      - Vector

        - ```cpp
          #include <iostream>
          #include <vector>
          using namespace std;

          int main() {
            vector<int> vec;
            vec.push_back(4); // add element to back
            cout << vec.size() << endl;
            
            vector<int>*vec1 = vector<int>;
            
            //point to certain element of vector
            //not recommended but legit
            int* p = &(vec[0]);
            
            //instead of just pointer, should use iterator instead
            vector<int>::iterator it = vec.begin();
            it[0] = 200;  
            
            delete vec;
            return 0;
          }
          ```

        - Can deference a iterator

      - Class container

        - ```cpp
          template <typename T>
          class Array{
          public:
            Array(int n=3);
            T& operator+(int ) {}
          }

          // constsructor cannot just do A::A()
          template <typename T>
           A<T>::A<T>() {
           }

          // member functions
          template <typename T>
          T& Array<T>::operator+(int a ){
            //bla bla bla
          }

          //use another typename for << and >> since may stream different type 
          template <typename S>
            friend ostream& operator<<(ostream& os, const Array<S>& x);

          int main() {
            Array<int> a(3), b(3);
          }
          ```

        - Preferred to use extension "tpp" instead of "cpp"

        - Apply `template <typename T>` to all functions in class except for `<<` and `>>` as 99.9% of time you will use them as global functions

      - Sequnce container

        - iterator

          - definition: generalized pointer

          - To transverse sequence container, must use iterator

          - STL sequence containers provide `begin()`, `end()` for setting iterator

          - e.g. implementing find function

            ```cpp
            typedef int* Int_Iterator; //define a new name for type, used mainly because get rid of pointer asteroid ;)

            Int_Iterator find(Int_Iterator begin, Int_Iterator end, const T& value) {
              while (begin != end && *begin != value)
                ++begin;
              return begin;
            }
            ```

          - STL algorithm are global functions

        - Predicate

          - definition: boolean function

          - e.g. Implementing find_if function

            ```cpp
            template<class Iterator, class Predicate>
              Iterator find_if(Iterator first, Iterator, last, Predicate predicate) {
                while (first != last && !predicate(*first))
                  ++first;
              	return first;
              }
            ```

            ​

        - Function pointer: (taken from C)

          - e.g. `int (*compare) (const void* , const void* )`
          - also qsort function uses function pointer. It is a C function
            e..g `qsorst(data, num_data, sizeof(data[0]), i_compare)`, where `i_compare` is the pointer to comparison function
          - Cannot directly dereference a void pointer, so need to static cast it before dereferencing

        - Function object: (function pointer with OOP concept)

          - i.e. `A obj; obj()`
          - can be passed to other function as parameter and used as function

  - Nested class

    - ```cpp
      class A {
        public:
        class B {
          //...
        }
      }
      int main() {
        A::B b;
      }
      ```

    - ​

  - Namespace

    - Namespace can span multiple classes/functions
    - Namespace can nest each other.
    - Global namespace: e.g.  `using namespace std`,  available at global i.e. file level
    - use namespace specifically: e.g. `using std::vector;using std::cout`

  - Inheritence

    - cannot only choose specific members to inherit

    - Function that can pass base class can pass its derived class as well

    - Liskov Principle: Parent pointer can point to child object

    - If want to call parent contructor, call it in member initizliation list e.g. 

      ```cpp
      class B: public A {
        B (int p, int q): b(q), A(p) { //A(p) will be executed before b(q)
        	a = p;
        	b = q;
        }
      }
      ```

    - Have to make sure base class have copy constructor too if want to do copy construct with derived class

    - Slicing: not recommended to copy from derived class to base class, since derived class has more members, and the not covered ones in base class will be dropped.

    - the methods called are based on the pointer type, not the type of variable it is pointing to

    - When a derive class is not supposed to have a member from its base class: missed :P

    - Public members in base clas are accessible to member functions of clas, any member functions of other classes and global functions

    - Protected members in base class are accessible in methods of derived class

    - private members in base class only accessible in member functions and friends of class
